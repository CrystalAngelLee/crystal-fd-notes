> 在JS代码执行的时候，浏览器在内存层面上所做到的一些底层处理。

# 堆栈

- JS执行环境(V8...)
- 执行环境栈（ECStack，execution constext stack）
- 执行上下文
- VO(G), 全局变量对象

```tex
JS 在执行的时候需要一个环境，所以浏览器下就会有一个JS执行引擎，比如V8
代码最终会被转为机器码，机器码在 执行环境栈(ECStack) 中被执行
浏览器在渲染界面时，会在计算机的内存中开辟一段内存空间，专门执行 JS 代码。栈内存就是 执行环境栈，不同的代码之间需要保持各自的独立，此时需要有 执行上下文（全局上下文、局部上下文）
比如 全局上下文 中存在一个变量a
变量a 存在于底层 VO(G) 变量对象所占据的空间中

有了上述中的内容后，全局中的代码可以进栈执行
```

---

我们来看一段代码：

```js
var x = 100;
var y = x;
console.log(x)
```

`var x = 100;` 干了啥？

1. 创建一个值 100，由于 100 是一个基本数据类型值，所以会直接存放在栈区
2. **声明一个变量，存放在了 VO(g)**
3. 建立变量与值之间的联系

```tex
1. 基本数据类型是按值进行操作
2. 基本数据类型值是存放在 栈区的；引用类型存放在堆区，将相应的地址存放在栈区，通过一个变量对其进行引用
3. 无论我们当前看到的栈内存，还是后续引用数据类型会使用的堆内存都属于计算机内存
4. GO：全局对象
4.1 它并不是 VO(G)，但是他也是一个对象，因此他也会有一个内存的空间地址
4.2 因为有地址就可以对其进行访问
4.3 JS在 VO(G) 中准备的一个变量 window
```

出栈之后，栈里面声明过的变量和值都会被释放掉



# 引用类型堆栈

通过以下代码进行分析

```js
var obj1 = { x: 100 }
var obj2 = obj1
obj2['x'] = 200
console.log(obj1.x)
```

**1. 首先会有一个执行环境栈ECStack存在**

**2. 相应代码在执行上下文（全局上下文EC(G)）中，进行进栈动作**
在全局上下文中存在`VO(G)` 全局变量对象，用于存放当前上下文中存在的一些变量

```tex
obj1   obj2
```

**3. 开辟堆内存**

遇到obj1 发现它里面的值是引用类型，所以在JS底层重新开辟一片空间**（堆）内存**，有自己的地址，后续通过地址进行访问。
内存中存放键值对

```js
x: 100
```

**4. 建立关系**

将obj1 和 堆内存建立关系。

```js
obj1 = 堆内存空间地址
```

**5. 第二行代码执行**

看赋值操作的右侧，找到 obj1，通过相应地址找到对应堆内存；
将堆内存地址赋值给obj2

**6. 第三行代码执行**

找到堆内存中的相应键，对其值进行修改

**7. 第四行代码执行**

访问obj1 对应的值（堆内存地址），查找空间里的对应值



🌰 **案例分析二**

```js
var obj1 = { x: 100 }
var obj2 = obj1
obj1.y = obj1 = { x: 200 }
console.log(obj1.y)
console.log(obj2)
```

1. 执行环境栈 ECStack

2. 在执行环境栈中存在一个执行上下文（全局上下文EC(G)）

3. EC(G)中存在 VO(G)

4. 变量提升后，将变量 `obj1、obj2` 存放到 VO(G) 中

5. 代码执行

   1. **第一行**
      开辟空间（堆内存）存放值，将地址存放于 VO(G) 中

   2. **第二行**

      将 obj1 存放的地址和 obj2 建立关系

   3. **第三行**

      1. 首先执行的是 obj1.y
         在 堆内存地址空间中 增加相应键值 y
         y 指向了一个对象，开辟一个新的堆内存空间，新的地址中存在的键值对是 `x: 200`
      2. 将 obj1 指向 新的堆内存空间地址
      3. 结论就是将obj1 的地址指向更换了

   4. **第四行**

      访问 obj1.y ，由于当前地址中不存在 y，所以返回undefined

   5. **第五行**

      访问 obj2，返回 {x: 100, y: {x: 200}}



# 函数堆栈处理

## 案例分析

**案例**

```js
var arr = ['1', '2']

function foo(obj) {
  obj[0] = '3',
  obj = ['4']
  obj[1] = '5'
  console.log(obj)
}

foo(arr)
console.log(arr)
```

**分析**

1. 执行环境栈 ECStack
2. 在执行环境栈中存在一个执行上下文（全局上下文EC(G)）
3. EC(G)中存在 VO(G)
4. 变量提升后，将变量 `arr、foo` 存放到 VO(G) 中， foo 指向堆内存地址
5. 代码执行
   1. **第一行**
      1. arr 变量进行赋值，发现是一个数组（对象）
      2. 给数组开辟堆内存空间
      3. arr 和 堆内存地址进行关联
   2. **foo 的定义看上文即可**
   3. **函数调用**
      目的就是为了将函数对应的堆内存里的字符串形式代码进行执行。代码在执行的时候肯定需要有一个环境，此时就意味着函数在执行的时候会生成一个新的执行上下文来管理函数体当中的代码
6. 产生新的执行上下文（私有上下文EC(FOO)）
7. EC(FOO)中存在 AO，用来存放当前上下文中的变量对象
8. 确定作用域链：<当前执行上下文，上级执行上下文>
9. 确定 this：window
10. 初始化 arguments 对象
11. 形参赋值： obj = arr堆内存地址
12. 变量提升
13. 执行代码
    1. **obj[0] = '3'**
       修改 arr堆内存地址 下的 0 为 ‘3’
    2. **obj = ['4']**
       重新开辟一个新的堆内存空间，放置相应对象
       将obj指向新的堆内存地址
    3. **obj[1] = '5'**
       修改 obj 指向的堆内存空间，添加新的键值
    4. **console.log(obj)**
       打印结果为新的内存空间中的内容，即 ['4', '5']
14. 函数体代码执行完毕，进行出栈操作，变量及值都会被释放，新增的堆内存空间交给GC工作
15. 代码执行：**console.log(arr)**
    ['3', '2']

**函数变量提升**

1. 创建函数和创建变量类似，函数名此时就可以看做是一个变量名
2. 函数在创建的时候会单独的开辟一块堆内存空间，也会有16进制地址，用来存放函数体（字符串形式代码）
3. 函数在创建的时候作用域[[scope]]就已经确定了（创建函数时所在的执行上下文）
4. 创建函数之后会将它的内存地址存放在栈区与对应的函数名进行关联

**函数执行时做的事情**

1. 确定作用域链：<当前执行上下文，上级执行上下文>
2. 确定 this
3. 初始化 arguments 对象
4. 形参赋值： obj = arr
5. 变量提升
6. 执行代码

## 总结

1、函数创建

可以将函数名称看做是变量，存放在 VO 中，同时它的值就是当前函数对应的内存地址
函数本身也是一个对象，创建时会有一个内存地址，空间内存放的就是函数体代码（字符串形式的）

2、函数执行

函数执行时会形成一个全新的私有上下文，它里面有一个AO 用于管理这个上下文当中的变量

步骤：

1. 确定作用域链：<当前执行上下文，上级执行上下文>
2. 确定 this
3. 初始化 arguments (对象)
4. 形参赋值：它就相当于是变量声明，然后将声明的变量放置于 AO
5. 变量提升
6. 执行代码
